#' @title
#' Working horse of the ecr package.
#'
#' @description
#' Takes a function and searches for a global optimum with an evolutionary approach.
#'
#' @keywords optimize
#'
#' @template arg_optimization_task
#' @template arg_control
#' @param initial.population [\code{list}]\cr
#'   List of individuals which should be placed in the initial population.
#'   The function will stop with an error message if the number of passed individuals
#'   is larger than \code{control$n.population}. If the number of passed individuals
#'   is lower than \code{control$n.population}, the population will be filled up
#'   by individuals generated by the corresponding generator.
#'   Default is \code{NULL}, i.e., the entire population is generated by the
#'   population generator.
#' @return [\code{\link{ecr_result}}]
#'
#' @example examples/ex_doTheEvolution.R
#' @seealso \code{\link{setupECRControl}}
#' @export
doTheEvolution = function(task, control, initial.population = NULL) {
  if (isSmoofFunction(task)) {
    task = makeOptimizationTask(task)
  }
  doFinalChecks(task, control)

  population = buildInitialPopulation(control$n.population, task, control, initial.population)
  population$fitness = evaluateFitness(population, task$fitness.fun, task, control)
  opt.state = setupOptState(task, population, control)
  fireEvent("onEAInitialized", control, opt.state)

  repeat {
    matingPool = selectForMating(opt.state, control)
    fireEvent("onMatingPoolGenerated", control, opt.state)

    offspring = generateOffspring(opt.state, matingPool, control)
    fireEvent("onOffspringGenerated", control, opt.state)

    population = getNextGeneration(opt.state, offspring, control)
    updateOptState(opt.state, population, control)
    fireEvent("onPopulationUpdated", control, opt.state)

    stop.object = doTerminate(opt.state, control)
    if (length(stop.object) > 0L) {
      break
    }
  }
  fireEvent("onEAFinished", control, opt.state)

  return(setupResult(opt.state, stop.object, control))
}

# @title
# Do some final checks before EA initialization.
#
# @param task [ecr_optimization_task]
#   Optimization task.
# @param control [ecr_control]
#   Control object.
doFinalChecks = function(task, control) {
  assertClass(task, "ecr_optimization_task")
  assertClass(control, "ecr_control")

  if (isSmoofFunction(task$fitness.fun) && control$representation == "custom") {
    stopf("Custom representations not possible for smoof functions.")
  }

  if (control$representation == "float" && !hasFiniteBoxConstraints(task$par.set)) {
    stopf("Lower and upper box constraints needed for representation type 'float'.")
  }

  # check compatibility of selectors and #objectives
  checkSelectorCompatibility(task, control, control$parent.selector, control$survival.selector)
}

# @title
# Check selectors for compatibility with objectives.
#
# @param task [ecr_optimization_task]
#   Optimization task.
# @param control [ecr_control]
#   Control object.
# @param ... [any]
#   List of ecr_selector objects.
# @return Nothing
checkSelectorCompatibility = function(task, control, ...) {
  selectors = list(...)
  desired.obj = if (task$n.objectives == 1L) "single-objective" else "multi-objective"
  lapply(selectors, function(selector) {
    if (desired.obj %nin% attr(selector, "supported.objectives")) {
      stopf("Selector '%s' cannot be applied to problem with %i objectives.",
        getOperatorName(selector), task$n.objectives)
    }
  })
}

# @title
# Helper function to build initial population.
#
# @param n.population [integer(1)]
#   Size of the population.
# @param task [ecr_optimization_task]
#   Optimization task.
# @param control [ecr_control]
#   Control object.
# @param initial.population [list | NULL]
#   Eventually a list of initial individuals.
# @return [ecr_population]
buildInitialPopulation = function(n.population, task, control, initial.population) {
  n.to.generate = n.population
  n.initial = 0L
  if (!is.null(initial.population)) {
    assertList(initial.population)
    n.initial = length(initial.population)
    if (n.initial > n.population) {
      stopf("Size of initial population (=%i) exceeds the specified population size %i.",
        n.initial, n.population)
    } else if (n.initial == n.population) {
      return(makePopulation(initial.population))
    }
  }
  populationGenerator = control$generator
  generated.population = populationGenerator(n.population - n.initial, task, control)
  if (n.initial > 0L) {
    return(makePopulation(c(generated.population$individuals, initial.population)))
  }
  return(generated.population)
}
