#' @title
#' Working horse of the ecr package.
#'
#' @description
#' Takes a function and searches for a global optimum with an evolutionary approach.
#'
#' @keywords optimize
#'
#' @template arg_optimization_task
#' @template arg_control
#' @param initial.population [\code{list}]\cr
#'   List of individuals which should be placed in the initial population.
#'   The function will stop with an error message if the number of passed individuals
#'   is larger than \code{control$n.population}. If the number of passed individuals
#'   is lower than \code{control$n.population}, the population will be filled up
#'   by individuals generated by the corresponding generator.
#'   Default is \code{NULL}, i.e., the entire population is generated by the
#'   population generator.
#' @return [\code{\link{ecr_result}}]
#'
#' @example examples/ex_doTheEvolution.R
#' @seealso \code{\link{setupECRControl}}
#' @export
doTheEvolution = function(task, control, initial.population = NULL) {
  if (control$representation != "custom") {
    if (isSmoofFunction(task)) {
      task = makeOptimizationTask(task)
    }
    assertClass(task$fitness.fun, "smoof_function")
    assertClass(task, "ecr_optimization_task")

    if (control$representation == "float" && !hasFiniteBoxConstraints(task$par.set)) {
      stopf("Lower and upper box constraints needed for representation type 'float'.")
    }
  }
  n.objectives = task$n.objectives

  # check compatibility of selectors and #objectives
  checkSelectorCompatibility(n.objectives, task, control, control$parent.selector, control$survival.selector)

  # new doTheEvolution
  monitor = control$monitor

  population = buildInitialPopulation(control$n.population, task, control, initial.population)
  population$fitness = evaluateFitness(population, task$fitness.fun, task, control)
  opt.state = setupOptState(task, population, control)

  monitor$before()
  repeat {
    matingPool = selectForMating(opt.state, control)
    offspring = generateOffspring(opt.state, matingPool, control)
    population = getNextGeneration(opt.state, offspring, control)

    updateOptState(opt.state, population, control)

    monitor$step()

    stop.object = doTerminate(opt.state, control)
    if (length(stop.object) > 0L) {
      break
    }
  }
  monitor$after()
  setupResult(opt.state, stop.object, control)
  # end of new doTheEvolution
}

# @title
# Generate 'extras' argument for opt.path.
#
# @param iter [integer(1)]
#   Current iteration/generation.
# @param n.evals [integer(1)]
#   Number of function evaluations.
# @param population [ecr_population]
#   Current population.
# @param start.time [POSIXct]
#   Start time of evolution process.
# @pram control [ecr_control]
#   Control object.
# @return [list] Named list with scalar values to be stored in opt.path.
getListOfExtras = function(iter, n.evals, population, start.time, control) {
  fitness = population$fitness
  extra = list(
    past.time = as.numeric(Sys.time() - start.time),
    iter = iter,
    n.evals = n.evals,
    pop.min.fitness = min(fitness),
    pop.mean.fitness = mean(fitness),
    pop.median.fitness = median(fitness),
    pop.max.fitness = max(fitness)
  )
  # compute and log used defined stuff
  if (!is.null(control$extras.fun)) {
    user.extra = control$extras.fun(population)
    if (!testList(user.extra, names = "strict")) {
      stopf("Result computed by 'extras.fun' is not a named list!")
    }
    extra = c(extra, user.extra)
  }
  return(extra)
}

# @title
# Helper function to build initial population.
#
# @param n.population [integer(1)]
#   Size of the population.
# @param task [ecr_optimization_task]
#   Optimization task.
# @param control [ecr_control]
#   Control object.
# @param initial.population [list | NULL]
#   Eventually a list of initial individuals.
# @return [ecr_population]
buildInitialPopulation = function(n.population, task, control, initial.population) {
  n.to.generate = n.population
  n.initial = 0L
  if (!is.null(initial.population)) {
    assertList(initial.population)
    n.initial = length(initial.population)
    if (n.initial > n.population) {
      stopf("Size of initial population (=%i) exceeds the specified population size %i.",
        n.initial, n.population)
    } else if (n.initial == n.population) {
      return(makePopulation(initial.population))
    }
  }
  populationGenerator = control$generator
  generated.population = populationGenerator(n.population - n.initial, task, control)
  if (n.initial > 0L) {
    return(makePopulation(c(generated.population$individuals, initial.population)))
  }
  return(generated.population)
}

# @title
# Check selectors for compatibility with objectives.
#
# @param n.objectives [integer(1)]
#   Number of objectives of the optimization task.
# @param task [ecr_optimization_task]
#   Optimization task.
# @param control [ecr_control]
#   Control object.
# @param ... [any]
#   List of ecr_selector objects.
# @return Nothing
checkSelectorCompatibility = function(n.objectives, task, control, ...) {
  selectors = list(...)
  desired.obj = if (n.objectives == 1L) "single-objective" else "multi-objective"
  lapply(selectors, function(selector) {
    if (desired.obj %nin% attr(selector, "supported.objectives")) {
      stopf("Selector '%s' cannot be applied to problem with %i objectives.",
        getOperatorName(selector), n.objectives)
    }
  })
}
