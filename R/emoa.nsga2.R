#' @title
#'   Implementation of the NSGA-II EMOA algorithm by Deb.
#'
#' @description
#'   The NSGA-II merges the current population and the generated offspring and
#'   reduces it by means of the following procedure: It first applies the non
#'   dominated sorting algorithm to obtain the nondominated fronts. Starting with
#'   the first front, it fills the new population until the i-th front does not fit.
#'   It then applies the secondary crowding distance criterion to select the missing
#'   individuals from the i-th front.
#'
#' @note
#'   This is a pure R implementation of the NSGA-II algorithm. It hides the regular
#'   \pkg{ecr} interface and offers a more R like interface while still being quite
#'   adaptable.
#'
#' @template arg_optimization_task
#' @param n.population [\code{integer(1)}]\cr
#'   Population size. Default is \code{100}.
#' @param n.offspring [\code{integer(1)}]\cr
#'   Offspring size, i.e., number of individuals generated by variation operators
#'   in each iteration. Default is \code{n.population}.
#' @template arg_parent_selector
#' @template arg_mutator
#' @template arg_recombinator
#' @template arg_max_iter
#' @template arg_max_evals
#' @template arg_max_time
#' @return [\code{ecr_ecr_multi_objective_result}]
#' @export
nsga2 = function(
  task,
  n.population = 100L, n.offspring = n.population,
  parent.selector = makeSimpleSelector(),
  mutator = makeGaussMutator(),
  recombinator = makeCrossoverRecombinator(),
  max.iter = 100L,
  max.evals = NULL,
  max.time = NULL) {

  # set up the core of NSGA-II, namely the survival selection
  nsga2SurvivalSelector = makeSelector(
    selector = function(population, storage, n.select, control) {
      inds = population$individuals
      fitness = population$fitness
      #print(fitness)
      nondom.layers = doNondominatedSorting(fitness)

      # storage for indizes of selected individuals
      new.pop.idxs = integer()

      # get maximum rank, i.e., the number of domination layers
      max.rank = max(nondom.layers$ranks)

      # get the indizes of points for each domination layer
      idxs.by.rank = lapply(seq(max.rank), function(r) which(nondom.layers$ranks == r))

      # get the number of points in each domination layer ...
      front.len = sapply(idxs.by.rank, length)

      # ... cumulate the number of points of the domination layers ...
      cum.front.len = cumsum(front.len)

      # ... and determine the first domination layer, which does not fit as a whole
      front.first.nonfit = which.first(cum.front.len > n.select)

      if (front.first.nonfit > 1L) {
        # in this case at least one nondominated front can be added
        new.pop.idxs = unlist(idxs.by.rank[1:(front.first.nonfit - 1L)])
      }

      # how many points to select by second criterion, i.e., crowding distance?
      n.diff = n.select - length(new.pop.idxs)

      if (n.diff > 0L) {
        idxs.first.nonfit = idxs.by.rank[[front.first.nonfit]]
        cds = computeCrowdingDistance(fitness[, idxs.first.nonfit, drop = FALSE])
        idxs2 = order(cds, decreasing = TRUE)[1:n.diff]
        new.pop.idxs = c(new.pop.idxs, idxs.first.nonfit[idxs2])
      }

      # merge the stuff and return
      return(makePopulation(inds[new.pop.idxs], fitness[, new.pop.idxs, drop = FALSE]))
    },
    supported.objectives = "multi-objective",
    name = "NSGA-II survival selector",
    description = "nondominated sorting with potential crowding distance"
  )

  if (isSmoofFunction(task)) {
    task = makeOptimizationTask(task)
  }
  assertClass(task, "ecr_optimization_task")

  # NSGA-II control object
  ctrl = setupECRControl(
    n.population = n.population,
    n.offspring = n.offspring,
    representation = "float",
    monitor = makeConsoleMonitor(),
    stopping.conditions = list(
      makeMaximumEvaluationsStoppingCondition(max.evals),
      makeMaximumTimeStoppingCondition(max.time),
      makeMaximumIterationsStoppingCondition(max.iter)
    )
  )
  ctrl = setupEvolutionaryOperators(
    ctrl,
    parent.selector = parent.selector,
    recombinator = recombinator,
    mutator = mutator,
    survival.selector = nsga2SurvivalSelector
  )

  return(doTheEvolution(task, ctrl))
}
